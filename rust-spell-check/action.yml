name: 'rust-spell-check'
description: 'Rust CI spellings check'
inputs:
  path:
    description: 'Path to repository folder to check spellings in.'
    required: false
    default: ./
  lexicon:
    description: 'Path to lexicon file to check spellings with'
    required: false
    default: lexicon.txt
  exclude-dirs:
    description: "Comma separated list of directories to not spell check"
    required: false
  exclude-files:
    description: "Comma separated list of files to not spell check"
    required: false
  include-extensions:
    description: "Comma separated list of files to match to regex"
    required: false


runs:
  using: "composite"
  steps:
    - env:
        bashPass: \033[32;1mPASSED -
        bashInfo: \033[33;1mINFO -
        bashFail: \033[31;1mFAILED -
        bashEnd:  \033[0m
        stepName: Install Dependencies
      name: ${{ env.stepName }}
      id: spell-checker-setup
      shell: bash
      working-directory: rust-spell-check
      run: |
        # ${{ env.stepName }}
        sleep 10;
        echo "::group::${{ env.stepName }}"

        # Install the Dependencies we need to run the spell-checker
        sudo apt-get install util-linux -y
        sudo apt-get install fd-find -y
        sudo apt-get install aspell -y
        sudo apt-get install spell -y

        # Check if we can use the current spell checker
        echo -e " ${{ env.bashInfo }} Check for pre-build spell checker ${{ env.bashEnd }}"
        set +e
        echo "ls = $(ls)"
        echo "PATH = $PATH"
        echo "pwd = $(pwd)"
        echo "find = $(find . -name "spell-checker)"
        export PATH="$(pwd):$PATH"
        spell-checker
        exitCode=$?
        set -e
        if ! [ $exitCode -eq 0 ]; then
          echo "::endgroup::"
          echo -e " ${{ env.bashFail }} Don't have the ability to use the current spell checker, building it ${{ env.bashEnd }}"
          echo "::group::Compile Spell Checker"

          echo "::group::Install Build Dependencies"

          # If we can't run the current one, install the tools we need to build it
          # Run one a time for error checking
          sudo apt-get install libaspell-dev -y
          sudo apt-get install build-essential -y
          sudo apt install rustc -y
          echo "::endgroup::Install Build Dependencies"

          echo -e "${{ env.bashInfo }} cargo --version = $(cargo --version) ${{ env.bashEnd }}"
          echo -e "${{ env.bashInfo }} rustc --version = $(rustc --version) ${{ env.bashEnd }}"

          cargo build --release
          echo "find = $(find . -name "spell-checker)"
          echo -e "ls target/release = $(ls target/release)"
          echo -e "ls  = $(ls)"
          mv $(find . -name "spell-checker) .
          spell-checker --help
          echo "::endgroup::Compile Spell Checker"
          # Only make it to here if nothing above fails
          echo -e "${{ env.bashPass }} Compiled the Spell Checker ${{ env.bashEnd }}"
        fi
        echo "::endgroup::"
        # Only get to here if nothing above fails
        echo -e "${{ env.bashPass }} ${{ env.stepName }} ${{ env.bashEnd }}"
        exit $exitCode

    - env:
        stepName: Run Spell Checker
      name: ${{ env.stepName }}
      id: run-spell-checker
      working-directory: ${{ inputs.path }}
      shell: bash
      run: |
        # ${{ env.stepName }}
        #echo "::group::${{ env.stepName }}"
        set +e
        echo "steps.spell-checker-setup.outcome=  ${{ steps.spell-checker-setup.outcome }}"
        export PATH="$PATH:$GITHUB_ACTION_PATH"
        echo "PATH=$PATH"
        set -e

        files=$(getFiles --exclude-dirs="${{ inputs.exclude-dirs}}" --exclude-files="${{ inputs.exclude-files }}" --include-extensions="${{ inputs.include-extensions }}")
        spell-checker -c -w .cSpellWords.txt $files
        exitStatus=$?

        #echo "::endgroup::"
        if [ $exitStatus -eq 0 ]; then
          echo -e "${{ env.bashPass }} ${{ env.stepName }} ${{ env.bashEnd }}"
        else
          echo -e "${{ env.bashFail }} ${{ env.stepName }} ${{ env.bashEnd }}"
          exit 1
        fi
